; Vamos traduzir o seguinte código para uma linguagem de alto nível equivalente, use as tecnicas apresentadas e os conceitos 
aprendidos e resolva esse desafio

mov dword ptr [ebp-8], 1
mov dword ptr [ebp-4], 0

loc_401014:
cmp dword ptr [ebp-4], 4
jge short lc_40102E
mov eax, [ebp-8]
add eax, [ebp-4]
mov [ebp-8], eax
mov ecx, [ebp-4]
add ecx, 1
mov [ebp-4], ecx
jmp short loc_401014

lc_40102E:
ret


Organizando o código

mov dword ptr [x], 1
mov dword ptr [y], 0

while:
cmp dword ptr [y], 4
jge short fim
mov eax, [x]
add eax, [y]
mov [x], eax
mov ecx, [y]
add ecx, 1
mov [y], ecx
jmp short while

fim:
ret


Resumo meneumonico

mov dword ptr [x], 1   ; X = 1;
mov dword ptr [y], 0   ; y = 0;

while:                 ; while
cmp dword ptr [y], 4   ; subtray 4 de y e seta a zero flag caso zero
jge short fim          ; jge salte se maior ou igual
mov eax, [x]	       ; EAX = x
add eax, [y]           ; EAX = y
mov [x], eax           ; x = EAX
mov ecx, [y]           ; ECX = y
add ecx, 1             ; ECX += 1
mov [y], ecx           ; y = ECX
jmp short while        ; volta ao label while

fim:                   ; fim
ret                    ; return



Peseudocode

x = 1;
y = 0;
while (y <= 4){
   EAX = x;
   EAX += y;
   x = EAX;
   ECX = y;
   ECX += 1;
   y = ECX; 
}
return;


Organizando sujeira

int x = 1;
int y = 0;
while(y <= 4){
  x += y;
  y += 1;
}
return;


Equivalente em C

void main(void){
     int x = 1;
     int y = 0;
     while (y <= 4){
	x += y;
        y += 1;
     }
     return;
}

Solução para o disassembly / Correção

O seguinte código consiste em dois endereços de memória usados (ebp-4 e ebp-8), vamos renomear ebp-4 para x e ebp-8 para y
o seguinte resultado é obtido como mostrado aqui:

mov dword ptr [y], 1
mov dword ptr [x], 0

loc_401014:
cmp dword ptr [x], 4
jge short lc_40102E
mov eax, [y]
add eax, [x]
mov [y], eax
mov ecx, [x]
add ecx, 1
mov [x], ecx
jmp short loc_401014

lc_40102E:
ret

no código precedente, temos algumas labels de saltos com prefixo "loc", indicando um loop, e algumas verificações em cima da variável x
onde verifica se x i maior ou igual a 4. se a condição for satisfeita, o salto será feito para fora do laço, baseado nessas informações
já podemos considerar x como a variável de update da condição.
veja como ficou:

y = 1;
x = 0;
while (x < 4){
   eax = y;
   eax = eax + x
   y = eax
   ecx = x
   ecx = ecx + 1
   x = ecx
}


Substituindo os registradores por algo mais amigavel:
y = 1;
x = 0;
while (x < 4){
   eax = y;
   eax = y + x;
   y = y + x;
   ecx = x;
   ecx = x + 1;
   x = x + 1;
}

Removendo os registradores de uma vez
y = 1;
x = 0;
while (x < 4){
  y = y + x;
  x = x + 1;
}

Vamos comparar com o fonte original:

int a = 1;
int i = 0;
while (i < 4){
   a = a + 1;
   i++;
}










