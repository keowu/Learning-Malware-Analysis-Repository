Desafio de Assembly #5
Traduza o seguite código para um linguagem de alto nível equivalente, use tecnicas e os conceitos aprendidos para conseguir resolver esse desafio.


push ebp
mov esp, esp
sub esp, 14h
mov dword ptr [ebp+14h], 1  
mov dword ptr [ebp+10h], 2
mov dword ptr [ebp+0ch], 3
mov dword ptr [ebp-4], 0

loc_401022:
cmp dword ptr [ebp-4], 3
jge loc_40103D
mov eax, [ebp-4]
mov ecx, [ebp+eax*4-14h]
mov [ebp-8], ecx
mov edx, [ebp-4]
add edx, 1
mov [ebp-4], edx
jmp loc_401022:

loc_40103D:
xor eax, eax
mov esp, ebp
pop ebp
ret


Organizando

push ebp
mov esp, esp
sub esp, 14h
mov dword ptr [ebp+14h], 1  ; x[1] = 1
mov dword ptr [ebp+10h], 2  ; x[2] = 2
mov dword ptr [ebp+0ch], 3  ; x[3] = 3
mov dword ptr [ebp-4], 0    ; i = 0

loc_401022:
cmp dword ptr [ebp-4], 3    ; 
jge loc_40103D              ; while (i <= 3)
mov eax, [ebp-4]            ; y = i
mov ecx, [ebp+eax*4-14h]    ; ecx = [x+i*4-0x14] 
mov [ebp-8], ecx            ; z = ecx
mov edx, [ebp-4]            ; edx = i
add edx, 1                  ; edx += 1
mov [ebp-4], edx            ; i = edx
jmp loc_401022:             ; volta ao inicio do loop

loc_40103D:                 ; sai do loop
xor eax, eax                ; zero o retorno eax ou return 0;
mov esp, ebp                ; recupera o topo da pilha
pop ebp                     ; pop na pilha
ret                         ; retorna


pseudo organizado
x = {1, 2, 3}
i = 0
while (i <= 3){
  valor = [x+i*4]; // -0x14 representa o base do array na stack
  z = valor
  i++
}
return 0;

equivalente em C

function calcula(){
   int x[4] = {1, 2, 3};
   int i = 0;
   int z = 0;
   while(i <= 3){
     valor = [x+i*4];
     z = valor;
     i++;
   }
}

- Correção
No exemplo usado, as primeiras duas instruções (push ebp e mov esp, esp) representam o prólogo da função.
Similar as duas linhas depois da última instrução.


push ebp
mov esp, esp
sub esp, 14h
mov dword ptr [ebp+14h], 1  
mov dword ptr [ebp+10h], 2   (7)
mov dword ptr [ebp+0ch], 3   (8)
mov dword ptr [ebp-4], 0     (4)

loc_401022:                  (2)
cmp dword ptr [ebp-4], 3     (3)
jge loc_40103D               (3)
mov eax, [ebp-4]             
mov ecx, [ebp+eax*4-14h]     (6)
mov [ebp-8], ecx       
mov edx, [ebp-4]             (5)
add edx, 1                   (5)
mov [ebp-4], edx             (5)
jmp loc_401022:              (1)

loc_40103D:
xor eax, eax
mov esp, ebp
pop ebp
ret


lembre-se no (6) a instrução representa o array acessado:
[ebp+eax*4-0x14], aqui 0x14 representa a base do endereço do array na stack, eax é o indice, 4 é o tamanho do dado

veja como ficou o pseudocódigo

val[0] = 1
val[1] = 2
val[2] = 3
i = 0
while (i < 3){
   eax = i
   ecx = [val+eax*4]
   [ebp-8] = ecx
   edx = i	
   edx = edx + i
   i = edx
}
return 0

vamos organizar os registradores para nomes mais amigaveis

val[0] = 1
val[1] = 2
val[2] = 3
i = 0
while (i < 3){
   [ebp-8] = [val+eax*4]
   i++
}

Agora uma pegadinha ebp-8 = X
Com oque aprendemos anteriormente nos acessamos o elementos usando um array de inteiros, nums[0], é o mesmo que [nums+0*4], 
e nums[1], é o mesmo que [nums+1*4], sempre seguira o padrão nums[i], é o mesmo que [nums+i*4].
Se você usou ebp-8 como local não é errado está muito certo, funcionaria porem o vamos tentar com val[3]
invés de ebp-8 como variavel local x, se você tentar ebp-8 como um elemento do array (ebp -8 = val[3]), então o código seria traduzido da seguinte
forma:

val[0] = 1
val[1] = 2
val[2] = 3
i = 0
while (i < 3){
   val[3] = [val+eax*4]
   i++
}


Agora vamos olhar para o código fonte original:

int main(){
  int a[3] = { 1, 2, 3 };
  int b, i;
  i = 0;
  while (i < 3){
    b = a[i];
    i++;
  }
  
  return 0;
}


se você conseguiu algo identico a isso parabéns, vai ficar bom !





