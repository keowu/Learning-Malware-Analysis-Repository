;   Use os conceitos aprendidos sobre Assembly nos capitulos anteriores para converter o assmbly para c

; ASSEMBLY CHALLENGE
mov dword ptr[ebp-4], 1
mov eax, dword ptr [ebp-4]
mov dword ptr [ebp-8], eax


; PRE SOLUTION
mov dword ptr[endereco_EBP_4], 1       ; Move o valor constante 1 para o endereço de memória de endereco_EBP_4
mov eax, dword ptr [endereco_EBP_4]    ; Move o conteúdo do endereço de memória´ endereco_EBP_4 para EAX
mov dword ptr [endereco_EBP_8], eax    ; Move EAX para um endereço de memória´ endereco_EBP_8



; C OUTPUT PSEUDOCODE
function challenge(){
	endereco_EBP_4 = 1; // move o valor 1 constante para uma posição da memória
	EAX = endereco_EBP_4; // move o valor presente na posição de memória para o registrador EAX
	endereco_EBP_8 = EAX; // move o valor de EAX para um endereço da memória novamente
}



;  BOOK SOLUTION
; Vamos quebrar a solução em partes para facilitar nosso entendimento sobre oque está ocorrendo

mov dword ptr [a], 1         ; Isso vai mover o valor 1 para o endereço de memória presente em a
mov eax, dword ptr [a]       ; Isso vai mover o valor do endereço de memória presente em A para EAX
mov dword ptr [b], eax       ; Isso vai mover o valor presente em EAX para um endereço de memória presente em b

; Na linguagem de alto nível quando é atribuido uma variável usamo val = 1, o val é atribuido da seguinte forma no assembly
mov dword ptr [val], 1 
; ou
mov [val], 1
; pensando dessa forma o programa acima poderia ser escrito da seguinte forma
mov dword ptr [a], 1
; a = 1
mov EXA, dword ptr[a]
; EAX = a
mov dword ptr [b], eax
; b = EAX

; mas sempre relembre que os registradores só são usados como armazenamentos temporários então podemos
a = 1
EAX = a   ; Eliminar esse aqui
b = EAX
; Eliminando ficará da seguinte forma:
a = 1
b = a

; É possível determinarmos o tipo de dado de um variável usando a seguinte base
; As variáveis não podem ser float por causa do código do disassembly, nós conhecemos o EAX e que ele envolve
; em transferência de operações, se fosse um valor de ponto flutuante, os registradores de ponto flutuante teriam sido usados
; ao invés de usar os registradores de uso geral como EAX, e também A e B não podem ser interpretadas como ponteiros nesse caso
; porque não existe o endereço 1, ele é inválido, então A e B só podem ser do tipo inteiro(int)

; com base nas observações feitas acima, temos o seguinte resultado de descompilação:
function RESULT(){
	int a;
	int b;
	a = 1;
	b = a;
}



; e o código original era
function OLAMUNDO(){

	int x = 1;
	int y;
	y = x;
}










