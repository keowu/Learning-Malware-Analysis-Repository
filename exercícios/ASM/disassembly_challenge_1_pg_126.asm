;   Use os conceitos aprendidos sobre Assembly nos capitulos anteriores para converter o assmbly para c

mov dword ptr [ebp-4], 1
cmp dword ptr [ebp-4], 0
jnz loc_40101C
mov eax, [ebp-4]
xor eax, 2
mov [ebp-4], eax
jmp loc_401025

loc_40101C:
mov ecx, [ebp-4]
xor ecx, 3
mov [ebp-4], ecx

loc_401025:
ret


Pseudocodigo

mov dword ptr [x], 1   ; x = 1
cmp dword ptr [x], 0   ; subtrai zero de eax e seta a zeroflag 1 caso zero '-' 
jnz saia               ; se não for zero, saía if (x != 0)
mov y, [x]             ; y = x 
xor y, 2               ; y ^= 2
mov [x], y             ; x = y
jmp else               ; salta para elseif

else:
mov z, [x]             ; z = x
xor z, 3               ; z ^= 3
mov [x], z             ; x = z

saia:
ret                    ; return


Equivalente em C
x = 1;
if (x == 0){
  y = x;
  y ^= 2;
  x= y;
}else{
  z = x;
  z ^= 3;
  x = z;  
}
return;


Equivalente corrigido em C

void XOR(int *x){
   x = 1;
   if ( *x == 0 ){
     *x ^= 2;
   }else{
     *x ^= 3;
   }
   return;
}


; Solução e correção do livro | Disassembly solution

Vamos inciar removendo e trocando os nomes dos acessos para recuperar valores em algo mais legivel, ou seja vamos remover os [ebp-4] e nos depararemos com o seguinte código:

mov dword ptr [x], 1   
cmp dword ptr [x], 0  
jnz saia              
mov y, [x]            
xor y, 2              
mov [x], y            
jmp else            

else:
mov z, [x]             
xor z, 3               
mov [x], z             

saia:
ret             

No seguinte código, é possível perceber as intruções cmp e jnz (são condições de estruturas de comparação), e perceba que jnz é o mesmo que o jne (salte se não for igual)
Agora basta identificar onde são usadas as estruturas de condições(if ou if/else...), para fazer isso basta prestar atenção nos jumps.

mov dword ptr [x], 1   
cmp dword ptr [x], 0  -> Salto
jnz saia              -> Salto
mov y, [x]            
xor y, 2              
mov [x], y            
jmp else              -> Salto 

else:
mov z, [x]             
xor z, 3               
mov [x], z             

saia:
ret           


No código IA-32, o x é definido com ovalor de 1 na primeira linha, o valor de x é comparado com zero, e se ele for igual a zero, o valor de x faz um xor com 2,
o resultado é armazenado nele mesmo, se x não for igual a x o xor é feito com 3.

se for feito a reescrita do código C a partir do Assembly, a condição da estrutura do if foi revertida quando analisada a partir do código Assembly, sem isso
não será possível reescrever o algoritmo, sem entender a estrutura de comparação.

x = 1;
if(x == 0){
  eax = x;
  eax = eax ^ 2;
  x = eax;
}else{
  ecx = x;
  ecx = ecx ^ 3;
  ecx = x;
}

agora temos que identificar dados a mais, depois vamos sobrebor todos os registradores por nomes amigavei.

x = 1;
if(x == 0){
  eax = x;
  eax = x ^ 2; -> pode ser simplificado
  x = x;
}else{
  ecx = x;
  ecx = x ^ 3; -> pode ser simplificado
  ecx = x;
}

E por fim após remover e simplificar os dados, obtemos o seguinte código fonte limpo:

x = 1;
if (x == 0){
   x = x ^ 2;
}else{
   x = x ^ 3;
}


e agora para encerrar, vamos conferir o fonte original do C:

int a = 1;
if (a == 0){
   a = a ^ 2;
}else{
   a = a ^ 3;
}
























