Conteúdo de anotações das páginas 150 - 156

- Instruções de laços com repeat (rep)
A instrução movsx copia de 1, 2 ou até 4 bytes, porem quando copiamos um multiplo de byte a instrução rep é usada
geralmente quando trabalhasse com strings a instrução rep depende do registrador ECX, e isso repete a string o número
de vezes em que foi especificado pelo registrador ECX, depois que encerrada a execução da instrução rep, o valor do registrador ECX
é decrementado.
veja o seguinte exemplo de código que demonstra o uso da instrução REP:

lea ESI, [SRC] ; "Good", 0x0
lea EDI, [DST]
mov ECX, 5
rep MOVSB


A instrução REP quando usada em conjunto com a instrução movsx, resulta no equivalente do memcpy() do C, A instrução REP possui
diversas formas, no qual permite a terminação \0, baseado nas condições que ocorrem durante o LOOP, a seguinte tabela mostra
as diferentes formas da instrução REP e outras condições:

___________________________________________________________________________
| Instrução         | Condição						   |
|	REP	    | Repete até que ECX seja zero   		           |
|   REPE, REPZ 	    | Repete até que ECX seja zero ou ZF = 0		   |
|  REPNE, REPNZ	    | Repete até que ECX seja zero ou ZZF = 1		   |
|__________________________________________________________________________|



- Armazenando valores do registrador para a memória (stosx)

A instrução stosb é usada para mover um byte do registrador da CPU(al) para a memória em um endereço especificado por EDI(Registrador de index de destino)
de maneira similar a stosw e stosd movem dados de AX(possui 2 bytes) e EAX(possui 4 bytes) para um endereço que é especificado pelo registrador EDI.
Normalmente, a instrução stosb é usada em conjunto com a instrução rep, para inicializar todos os buffers de bytes com algum valor, o seguinte código Assembly
preenche o buffer de destino com 5 double word(dword), em outras palavras a instrução inicia 5*4 = 20 bytes da memória com zero, a instrução rep quando usada com stosb
é o mesmo que usar um memset() do C.

mov EAX, 0
lea EDI, [DEST]
mov ECX, 5
rep stosd

- Carregando da memória para o registrador (lodsx)

A instrução lodsb move um byte da memória para um endereço especificado por ESI(O destino para o registrador indíce)
para o registrador AL. de maneira similar a lodsw e lodsd movem 2 bytes e 4 bytes de dados da memória para endereços
especificados por ESI e para AX e EAX.

- Buscando na memória (scasx)

A instrução scasb é usada para buscar(ou scanear) para a presença ou abstenção de uma sequencia de bytes. o byte a ser buscado
é armazenado no registrador AL, e o endereço do buffer é colocado no registrador EDI, a instrução scasb é a mais usada com a
instrução repne(repne scasb), com ECX definido o tamanho do buffer, isso interage com cada byte até que ele encontre o byte especificado
no registrador AL, ou até ECX ser zero.

- Comparando valores na memória (cmpsx)

A instrução cmpsb é usada para comparar um byte da memória com um byte especificado pelo registrador ESI.
A cmpsb é normalmente usado com repe(repe cmpsb) para comparar dois buffers, nesse caso ECX sera definido com o tamanho do buffer, e a comparação
vai continuar até ECX = 0, ou os buffers não serem iguais.

- Struturas

Uma estrutura é um grupo de diferentes tipos de dados juntos, cada elemento dessa estrutura é chamado de membro. Os membros da estrutura são acessados
usando offsets constantes, para entender o conceito, de uma olhada no seguinte exemplo em C. a definição da simpleStruct contem variáveis de estruturas
(&test_struct) é passado como um primero argumento, para atualizar dentro da função update, o membros da variáveis são assinados.

struct simpleStruct{
   int a;
   short int b;
   char c;
};

void update(simpleStruct *test_struct){
  test_struct->a = 6;
  test_struct->b = 7;
  test_struct->c = 'A';
}

int main(){
  struct (simpleStruct  test_struct;
  update(&test_struct);
  return 0;
}


na ordem para entender como os membros da estrutura são acessados, vamos olhar para a saída do disassembler, da função update o endereço base da estrutura é movido
para o registrador EAX(Lembre-se que EBP+8 significa o primeiro elemento, no nosso caso o elemento endereço base da estrutura), até esse estágio, EAX contem a base da estrutura,
Após é possível ver o valor 6 sendo movido para EAX, lembre-se que [EAX+0] represent ao primeiro membro da estrutura, perceba que ECX recebera 7 e que [EAX+4] segundo membro da estrutura
recebera o valor de CX, por fim temos o ultimo membro sendo atribuido nesse caso [EAX+6] com A.

push EBP				; STACK 
mov ESP, ESP				; CONFIGURA
mov EAX, [ESP+8]       			; Move para EAX o ponteiro para o endereço da strutura
mov doword ptr [EAX], 6			; Move para EAX o valor 6, EAX é o primeiro endereço e aponta para o primeiro membro da estrutura
mov ECX, 7           			; Move o valro 7 para ECX
mov [EAX+4], CX                         ; Move para [EAX+4] o valor de CX(7)
mov byte ptr [EAX+6], 41h		; Move para [EAX+6] o valor 41h(A)
mov ESP, EBP				; Retorna a stack ao original
pop EBP					; Limpa o registrador EBP
ret					; Retorna


pseudocode

EAX = [ESP + 8]
[EAX] = 6
[EAX+4] = 7
[EAX+6] = 41H

C

void main(){
   *x = &pStrutura;
   x->v1 = 6;
   x->v2 = 4;
   x->v3 = 'A';
}

Para o seguinte exemplo, é possível ver que cada membro da estrutura tem seu próprio offset para ser acessado
com a soma de um offset constante com o endereço base, então, a forma geral pode ser escrita da seguinte forma:

[base_address + constant_offset]

As struturas podem parecer muito familiar com os arrays na memória , mas você precisa relembrar alguns pontos que distingue eles:
	-> Elementos de um Array sempre tem o mesmo tipo de dados, enquanto struct não necessitam ter o mesmo tipo
	-> Arrays tem elementos mais acessados por váriaiveis offsets do seu base, (como [eax+ebx] ou [eax+ebx*4]), ao invés disso struturas
	são mais acessadas pelo seu endereço base com somas(como [EAX+4]).

- Arquitetura x64

Uma vez que os conceitos de x86 foram entendidos, é muito fácil entender a arquitetura x64, a arquitetura de x64 foi projetada para ser um extenção
da arquitetura x86, a arquitetura x86 tem uma enorme compatibilidade com a x64 porem com algumas diferenças, 

	-> A primeira diferença é são os registradores de 32-Bit(4 Bytes), EAX, EBX, ECX, EDX, ESI, EDI, EBP E ESP, são expandidios para 64-Bit(8 Bytes), 
	esses registradores foram renomeados para RAX, RBX, RCX, RDX, RSI, RDI, EBP e RSP. os maiores registradores foram renomeados r8, r9, r10, r11, r12, r13
        r14 e r15, como esperado o programa pode acessar registradores de 64-Bit, 32-Bits e 16-Bits, por exemplo é possível acessar o meio de um registrador RAX
	usando o EAX, e a menor parte com AX, pode-se acessar os registradores r8-r15 como byte, word, dword ou qword acrescentando b, w, d ou q aos nomes dos registradores.
	-> A arquitetura x64 pode carregar 64-Bit(8 Bytes) de dados, e ambos podem ser ponteiros para valores de 64-bit(8 Bytes) de tamanho.
	-> A CPU x64 tem um ponteiro de instrução(RIP) de 64-bits, e as rflags.
	-> A arquitetura x64 suporta rip-relativo como meio de endereçamento, O registrador RIP pode ser usado para referenciar locais de memória, isso é, você consegue acessar dados 
	de uma localização através de um offset para o endereço atual.
	-> Outra grande diferença é que na arquitetura x86, o parametro das funções são puxados para a stack como mencionado anteriormente, ao invés da arquitura x64, os primeiros quatro parâmetros
	são passados para a stack, veja um exemplo de um código simples em C para entender a diferença:
	
printf("%d %d %d %d %d", 1, 2, 3, 4, 5);

O seguinte é o equivalente para o disassembler de um código C compilado para um processador de 32-Bit(x86), nesse caso, todos esses parâmetros são enviados para dentro da stack (Com ordem refersa baseado no endian),
depois do uso do printf a stack é limpa, veja:

push 5			; Pusha 5 para a stack
push 4			; Pusha 4 para a stack
push 3			; Pusha 3 para a stack
push 2			; Pusha 2 para a stack
push 1			; Pusha 1 para a stack
call offset format	; "%d %d %d %d %d" <- mascara para o printf
call ds:printf		; chamada para a tabela de importação printf
add esp, 18h		; limpa a stack

Veja o mesmo código porem compilado para um processador de 64-bit(x64), a primeira instrução do exemplo a seguir, aloca 0x38(59 Bytes) de espaço na stack, o 1º, 2º, 3º e 4º parametro são armazenados em RCX, RDX, R8 e R9
(Depois é feita uma chamada para printf), os primeiros 6 parâmetros são armazenados na stack(No espaço alocado), usando as intruções mov, instruções push não são utilizadas nesse caso, dificultando o trabalho de identificar o endereço
na memória de uma variável local ou um parâmetro para a função, o formato string ajuda a determinar o número de parâmetros para a função printf, porem em outros casos isso não é tão simples.

sub ESP, 38h			; Stack alocação
mov dword ptr [rsp+28h], 5	; Move para a stack 5
mov dword ptr [rsp+20h], 4	; Move para a stack 4
mov r9d, 3			; Move para a stack 3
mov r8d, 2			; Move para a stack 2
mov edx, 1			; Move para a stack 1
lea rcx, Format			; "%d %d %d %d %d" <- mascara do printf
call cs:printf			; chamada para o printf da tabela de importação kernel32.dll


 _ 
| |		As arquiteturas Intel 64(x64) e o IA-32(x86), consistem em diversas instruções, se você
| |     	se cruzar com alguma instrução Assembly não coberta aqui, você pode baixar o manual da 
| |		intel nesse link: https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html
|_|     	e o set de instruções referidos aqui são dos valumes 2A, 2B, 2C e 2D e podem ser baixados em:
(_)		https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf



- Analizando executáveis de 32-Bit na arquitetura de 64-Bit do windows

O Sistema operacional Windows de 64-Bit, consegue rodar binários de 32-bit, para fazer isso, o Windows usa uma subsystem chamada de WOW64(Windows 32-Bit on Windows 64-Bit), WOW64 subsystem
permite a execução de binarios de 32-bit, no windows 64-Bit, Quando você carrega um executável ele precisa carregar a DLL para chamar a API para interagir com o sistema operacional.
Um binário de 32-Bit não pode carregar uma DLL de 64-Bit(e um processador de 64-Bit não pode rodar uma DLL de 32-Bit), então a Microsoft separou as DLL'S de 64-Bit e de 32-Bit, Os binários de
64-Bit são armazenados em \Windows\system32, e as DLL'S de 32-Bit são armazenadas em \Windows\Syswow64.

! Fique atento quando estiver analisando um malware de 32-bits em um ambiente de 64-bits, pode ser que ele esteja acessando o diretório \Syswow64 ao invés do system32.

 _ 
| |	Para ter uma ideia de como o WOW64 pode impactar suas analises, leia o seguinte artigo do pesquisador de tecnologia Christan Wojner:	
| |     https://www.fbiic.gov/public/2012/sep/cert_at_the_wow_effect.pdf
| |		
|_|     	
(_)		



- Recursos adicionais

O Seguintes recursos adicionais podem ajuda-lo a ganhar um profundo entendimento da linguagem C
	-> https://www.programiz.com/c-programming
	-> https://ptgmedia.pearsoncmg.com/images/9780789751980/samplepages/0789751984.pdf
	-> https://www.tutorialspoint.com/assembly_programming/index.htm
	-> http://pacman128.github.io/pcasm/
	-> https://opensecuritytraining.info/IntroX86.html
	-> https://www.amazon.com.br/Assembly-Language-Step-Step-Programming/dp/0470497025
	-> https://www.amazon.com/Introduction-Bit-Windows-Assembly-Programming/dp/1484921968
	-> https://en.wikibooks.org/wiki/X86_Disassembly

Sumário:

Nesse capitúlo você aprendeu conceitos e tecnicas necessários para entender e interpretar o código Assembly
Esse capitulo lhe deram conceitos chaves para entender as diferenças entre as arquiteturas x32 e x64. 
Os conceitos de disassembly e decompiler(código estático) foram as habilidades que você aprendeu nesse capitulo, nas próxima serão abordados disassembler e debbugers
usando ferramentas profissionais, e você vai aprender diversas vantagens que essas ferramentas te oferecem para facilitar sua analise e ajudar você a inspecionais o código
de um software ou malware.
