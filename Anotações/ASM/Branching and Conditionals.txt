Conteúdo de anotações das páginas 121 - 129

Nessa seção vamos focar nas intruções de Ganchos(if's), até então, nesse livro só vimos intruções de execução sequencial, mas na maioria das vezes
programa seguem diferentes linhas de execução em diferentes regiões de memória(como If/else condicional, loops e funções e mais), isso  só é possível
devido as intruções de branching. elas transferem o controle da execução para diferentes posições da memória, para fazer isso no IA-32(Assembly x86 ou x64)
tipicamente é usado intruções de salto, nos temos dois tipos de salto, os condicionais e os não condicionais.

- Saltos não condicionais
Nos saltos não condicionais, é obrigatorio que o salto seja feito, isso é similar a estrutura do goto nas linguagens de alto nível que também fazem esse tipo de salto,
o seguinte exemplo abaixo demonstra o funcionamento do jmp(salto não condicional). ele receberá a instrução JMP seguida do endereço para salto e quando o EIP chegar nele
o salto é executado, exemplo:

jmp <Endereço para o salto obrigatório>

- Saltos condicionais
Nos saltos condicionais o controle é transferido para memória baseado em algumas condições, para usar esse tipo de salto é necessário alterar as flags(setar ou limpar)
Essas instruções conseguem fazer operações aritiméticas ou de bitwise.
As instruções x86 provem da intrução CMP, essa instrução subtrai o operador de origem com o de destino, e altera as flags sem alterar a diferença no destino.
no seguinte exemplo abaixo se EAX conter o valor 5, a zero flag(ZF = 1), pois o resultado da operação vai resultar em zero.


cmp EAX, 5 ; Subtrai EAX de 5, e seta a flag mas o resultado não é armazenado no registrador EAX

Outra instrução usada que consegue alterar as flags sem alterar o valor de nenhum registrador é o test, o test faz o bitwise and e altera as flags 
sem interferir no valor do registrador de destino usado, no seguinte exemplo, se o valor de EAX é zero então a zero flag(zf) é setada (zf = 1),
porque o quando tentamos fazer and de 0 e 0 o resultado é 0:

test EAX, EAX ; faz a operação de AND, altera a flag mas o resultado da operação não é armazenado

As vezes, as intruções CMP e TEST são usadas ao longo de uma condição jum para tomada de decisão

Há algumas variações de saltos condicionais, o formato geral é o seguinte:

jcc <endereço do salto>

O cc representa a condição, Essas condições são avaliadas com base nos bits dos registradores de eflags. a tabela de exemplo armazena diferentes
tipos de saltos condicionais, suas declarações e os bits usados por suas eflags para condição:

Instrução                           Descrição                       Aliases                                Flags
JZ				   Pule se for zero		    JE					   ZF = 1
JNZ                                Pule se não for zero             JNE                                    ZF = 0
JL                                 Pule se for menor                JNGE                                   SF = 1
JLE				   Pule se for menor ou igual       JNG                                    ZF = 1 OU SF = 1
JG                                 Pule se for maior                JNLE			           ZF = 0 E SF = 0
JGE                                Pule se for maior ou igual       JNL                                    ZF = 0
JC                                 Pule se carry                    JB, JNAE                               CF = 0
JNC                                Pule se não carry                JNB, JAE                               .



- Estrutura do IF
Da perspectiva de um egenheiro reverso, é muito importante identificar as estruturas de branch/condições, para fazer isso é essencial ter entendimento
de estruturas de branch/condições como por exemplo (if, if-else, ilf-else if-else) como são traduzidos para a linguagem Assembly, Vamos olhar um exemplo
de um simples programa em C e tentar entender sua estrutura de if e como ela é implementada no nível Assembly:

if (x == 0){
	x = 5;
}
x = 2;

No precedente programa em C, se a condição (if x == 0), o código dentro do bloco do if é executado, por outro lado se você ignorar o bloco de desição
e pular para (x == 2), pense como o a instrução de controle controla o salto, e se você se perguntar e se o salto for considerado ? o salto será considerado
quando o x não for igual a 0. isso é exatamente como o assembly representa suas intruções, no exemplo a seguir perceba que o x é comparado com zero e que na
segunda expressão ele compara se x não é igual a zero e efetua o salto, veja o exemplo:


cmp dword ptr [x], 0
jne fim_do_if
mov dword ptr [x], 5
fim_do_if:
mov dword ptr [x], 2


- 6.4 Estrutura do If-Else

Agora, vamos tentar entender como a estrutura do if/else é traduzida para a linguagem assembly. vamos ter como exemplo o seguinte código em C:

if (x == 0){
   x = 5;
}else{
   x = 1;
}

No seguinte exemplo tentaremos idenficiar em qual condição o salto será considerado, e em quais circunstancias.
Temos duas circustancias, o jump será feito quando x não for igual a zero ou se o xx é igual a zero, então depois da execução da instrução
que x = 5 (Dado pelo end no final do bloco de instruções), um salto é usado para dar um bypass no bloco do else, no proximo exemplo será possível
visualziar melhor:

cmp dword ptr [x], 0   ; compara se X == 0, subtraindo 0 do valor de X e verificando o resto e setando a zero flag
jne else               ; Salta se x não for zero
mov dword ptr [x], 5   ; x = 5
jmp end                ; salta para o fim

else:                  ; caption do else
mov dword ptr [x], 1   ; x = 1

end:                   ; Caption do end
 syscall               ; syscall

Equivalente em c para treino

if (x == 0){
   x = 5;
}else{
   x = 1
}



- 6.5 if-elseif estrutura
O seguinte exemplo é o equivalente para C da estrutura do if-elseif-else:

if (x == 0){
   x = 5;
}else if (x == 1){
   x = 6;
}else{
   x = 7;
}

Para esse exemplo de código, é possível tentar determinar a situação de quando saltos de controles são usados, há dois tipos de pontos de salto,
se o x não for igual a zero, ele saltara para o bloco do elseif, e o x não igual a 1 (condição verificada no bloco do else if), então o salto
é considerado para o else veja um exemplo:
cmp dword ptr [ebp-4], 0 
jnz else_if
mov dword ptr [ebp-4], 5
jmp short end
else_if:
cmp dword ptr [ebp-4], 1
jnz else
mov dword ptr [ebp-4], 6
jmp short end

else:
mov doword ptr [ebp-4], 7
end:

Pré-peseudocode

cmp dword ptr [x], 0 
jnz else_if
mov dword ptr [x], 5
jmp short end
else_if:
cmp dword ptr [x], 1
jnz else
mov dword ptr [x], 6
jmp short end

else:
mov doword ptr [x], 7
end:

Decompiled

if (x == 0){
  x = 5;
  return; // Equivalente ao jmp short end
}else if (x == 1){
  x = 6;
}else{
  x = 7
}


Desafio de Assembly #3
I seguinte disassembler é a saída de um programa, vamos traduzir para um linguagem equivalente de alto nível, use as técnicas e conceitos aprendidos
para resolver.







































