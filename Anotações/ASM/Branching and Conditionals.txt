Conteúdo de anotações das páginas 121 - 

Nessa seção vamos focar nas intruções de Ganchos(if's), até então, nesse livro só vimos intruções de execução sequencial, mas na maioria das vezes
programa seguem diferentes linhas de execução em diferentes regiões de memória(como If/else condicional, loops e funções e mais), isso  só é possível
devido as intruções de branching. elas transferem o controle da execução para diferentes posições da memória, para fazer isso no IA-32(Assembly x86 ou x64)
tipicamente é usado intruções de salto, nos temos dois tipos de salto, os condicionais e os não condicionais.

- Saltos não condicionais
Nos saltos não condicionais, é obrigatorio que o salto seja feito, isso é similar a estrutura do goto nas linguagens de alto nível que também fazem esse tipo de salto,
o seguinte exemplo abaixo demonstra o funcionamento do jmp(salto não condicional). ele receberá a instrução JMP seguida do endereço para salto e quando o EIP chegar nele
o salto é executado, exemplo:

jmp <Endereço para o salto obrigatório>

- Saltos condicionais
Nos saltos condicionais o controle é transferido para memória baseado em algumas condições, para usar esse tipo de salto é necessário alterar as flags(setar ou limpar)
Essas instruções conseguem fazer operações aritiméticas ou de bitwise.
As instruções x86 provem da intrução CMP, essa instrução subtrai o operador de origem com o de destino, e altera as flags sem alterar a diferença no destino.
no seguinte exemplo abaixo se EAX conter o valor 5, a zero flag(ZF = 1), pois o resultado da operação vai resultar em zero.


cmp EAX, 5 ; Subtrai EAX de 5, e seta a flag mas o resultado não é armazenado no registrador EAX

Outra instrução usada que consegue alterar as flags sem alterar o valor de nenhum registrador é o test, o test faz o bitwise and e altera as flags 
sem interferir no valor do registrador de destino usado, no seguinte exemplo, se o valor de EAX é zero então a zero flag(zf) é setada (zf = 1),
porque o quando tentamos fazer and de 0 e 0 o resultado é 0:

teste EAX, EAX ; faz a operação de AND, altera a flag mas o resultado da operação não é armazenado

As vezes, as intruções CMP e TEST são usadas ao longo de uma condição jum para tomada de decisão

Há algumas variações de saltos condicionais, o formato geral é o seguinte:

jcc <endereço do salto>

O cc representa a condição, Essas condições são avaliadas com base nos bits dos registradores de eflags. a tabela de exemplo armazena diferentes
tipos de saltos condicionais, suas declarações e os bits usados por suas eflags para condição:

Instrução                           Descrição                       Aliases                                Flags
JZ				   Pule se for zero		    JE					   ZF = 1
JNZ                                Pule se não for zero             JNE                                    ZF = 0
JL                                 Pule se for menor                JNGE                                   SF = 1
JLE				   Pule se for menor ou igual       JNG                                    ZF = 1 OU SF = 1
JG                                 Pule se for maior                JNLE			           ZF = 0 E SF = 0
JGE                                Pule se for maior ou igual       JNL                                    ZF = 0
JC                                 Pule se carry                    JB, JNAE                               CF = 0
JNC                                Pule se não carry                JNB, JAE                               .



- Estrutura do IF
Da perspectiva de um egenheiro reverso, é muito importante identificar as estruturas de branch/condições, para fazer isso é essencial ter entendimento
de estruturas de branch/condições como por exemplo (if, if-else, ilf-else if-else) como são traduzidos para a linguagem Assembly, Vamos olhar um exemplo
de um simples programa em C e tentar entender sua estrutura de if e como ela é implementada no nível Assembly:

 


