Conteúdo de anotações das páginas 166 - 119

- Operações aritiméticas
No Assembly é possível fazer operações matemáticas como adição subtração e multiplicação e divisão.

Adição e subtração usam os seguintes opcodes
ADD, SUB
Ambos recebem um destino e uma origem, sendo o resultado armazenado no destino

* Essas flags podem setar ou limpar registradores eflags em algumas condições como por exemplo, na instrução sub
caso a ZF se o resultado for zero, e a carry flag caso a variável de destino seja menor que a origem os seguinte exemplos abaixo causam algumas dessas condições:

add EAX, 2      ; É o mesmo que EAX = EAX + 42;
add EAX, EBX    ; É o mesmo que EAX = EAX + EBX OU EAX += EBX;
add [ebx], 47   ; Soma o valor 47 ao valor presente no endereço especificado por EBX

Temo também os operadores de INC (INCREMENTO) e DEC (DECREMENTO), que podem ser usados para adicionar 1 ou subtrair 1 de um registrador ou local na memória
veja um exemplo:
inc EAX ; é o mesmo que EAX += 1;
dec EBX ; é o mesmo que EBX -= 1;

Outro exemplo a ser definido é que também é possivel usar um endereço de memória com um valor armazenado para incrementar(INC) ou decramentar(DEC), exemplo:
inc [0x77691310]  ; Obtem o endereço e recupera seu valor e soma 0x01 a ele exemplo *EAX += 0x01
dec [0x77691310]  ; Obtem o endereço e recupera seu valor e subtrai 0x01 a ele exemplo *EAX -= 0x01 

Multiplicações pode ser feito usando o operador mul, o mul usa somente um operador é multiplicador pela sua metade al, ax ou eax
e o resultado é armazenado em ax, dx, ax ou edx e eax

Se o operador da instrução do mul for 8 bits(1 byte) então é multiplicado por al que também é 8bit e seu produto é armazenado em ax.
Se o operador da instrução for 16 bits(2 bytes) então ele multiplicará por ax e o produto resultado será armazenado nos registradores dx e ax.
Se o operador da instrução for 32 bits (4 Bytes) então a multiplicação é feita com o registrador EAX e o produto é armazenado nos registradores EDX e EAX.

Observação:
Caso o operando é de 1 byte ou 8-bit, o valor na memória após o produto dobra, então usase um registrador de 16-bit(2 bytes), pois o valor pode ser maior dessa froma evita-se a carry flag

veja um exemplo claro:
mul ebx    ; EBX é multiplicado com EAX e o resultado é armazenado em EDX e EAX
mul bx     ; BX é multiplicado com AX e o resultado é armazenado em DX e AX

Também é possível usar a divisão no Assembly IA-32, da mesma forma usando um valor do registrador ou recuperando um valor da memória com os [], a diferença é que ele recebera somente um operando
Para fazer a divisão você coloca o divendo(número para dividir) em EDX, e EAX. como EAX ele usara a mais significando DWORD. Depois que a instrução do opcode for executada ele armazena o quociente
no registrador EAX, e a sobra da divisão(RESTO ou MOD) é armazenado no registrador EDX

DESÁFIO DE DISASSEMBLER #2 Página 117
