Conteúdo de anotações das páginas 120 - 121

Nessa seção vamos aprender sobre operadores com bits, vamos entender as instruções de bitwise, os bits são números iniciando pelo lado alto direito
O bit mais significante possui um bit na posição zero, e a posição dos bits avançam em direção a esquerda, o bit mais significante a esqueda tem o
apelido de bit significante, o exemplo abaixo mostra como são organizados os bits e asposições usadas para representar 0x5D
			_________________________
			| 0  1  0  1  1  1  0  1 |
                        |________________________|
			  7  6  5  4  3  2  1  0    Posição de cada bit


-  intrução NOT
 Recebe somente um operando, que serve tanto para origem como para destino, e inverte todos os bits do valor desse operado, exemplo:
se temos em EAX o valor de 0xFFFF0000(11111111 11111111 00000000 00000000) se usarmos a intrução NOT os valores são invertidos e exibidos da seguinte
forma: 0x0000FFFF (00000000 00000000 11111111 11111111), veja na prática:


NOT EAX

O AND, OR e o XOR, fazem bitwise e da mesma forma recebem uma origem e um destiono. um fato interessante é que esses operadores AND(&), OR(|) e XOR(^)
são os mesmos para C e Python, no exemplo abaixo o operador AND é usado para modificar seus bits, veja:

and bl, cl ; É o mesmo que bl = bl & cl ou b &= cl

no exemplo do disassembly se supormos que o bl contém o valor 5 (0000 0101) e que cl contém  6 (0000 0110) então o resultado será 4 (0000 0100), veja
o exemplo:

			bl = 0000 0101 <- destino 
                        cl = 0000 0110 <- origem
			--------------
			bl = 0000 0100 <- destino

De maneira similar, o OR e o XOR também podem ser representados dessa maneira, veja os exemplos:

OR EAX, EBX      ; é o mesmo que EAX = EAX | EBX ou tembém EAX |= EBX 
XOR EAX, EAX; é o mesmo que EAX = EAX ^ EAX ou também EAX ^= EAX, algo curioso é que se fazer a operação com um mesmo registrador serve para limpa-lo

- SHR(shift right) e SHL(shift left)
As intruções SHR e SHL usam dois operadores(destino e contador), contador ? sim, a quantidade de deslocamentos a serem feitas.  
As referências podem ser tanto para algum local da memória com os [] como para o conteúdo de um registrador, de maineira geral essas intruções fazem
o shift com os bits no destino, essas intruções podem ser repesentadas em alto nível com >>(Right shift) <<(Left shift) tanto para C como Python
Veja um exemplo:

shl destino, quantidade ;  destiono << quantidade

No próximo exemplo, a primeira instrução (xor EAX, EAX) vai limpar nosso registrador ou seja será zerado.
depois disso é movido para sua parte baixa al o valor 4 (0000 0100), com esse valor será feito um shl com 2(0000 0010), resultando no valor 0x10(0001 0000)
veja o exemplo completo:

XOR EAX, EAX     ; Limpa o registrador EAX, zerando seu valor
MOV AL, 4        ; Move 4 para parte baixa de AL
SHL AL, 2        ; Faz o shift left com 2

O livro recomenda a leitura do seguinte artigo sobre bitwise:
https://en.wikipedia.org/wiki/Bitwise_operations_in_C
https://www.programiz.com/c-programming/bitwise-operators

- ROL (rotate left) e o ROR (rotate right)
Elas são instruções similares com as de operações de shift porem ao invés de remover os bits com shift, eles são rotacionados para o final veja um exemplo:

ROL AL, 2   ; Neste exemplo se al conter 0x44 (0100 0100), o resultado do rol será de 0x11 (0001 0001), repare que os bytes foram todos ao final deslocando as duas casas informadas sem remover






