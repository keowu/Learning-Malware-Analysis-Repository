RESUMO DA PÁGINA 99 A 116

BYTE [55]
WORD [8B][EC]
DWORD [00][01][36][CF] 
      \------/ \----/
	HIGH     LOW

[00][01][36][CF] [00][01][36][CF]
   \--------/       \--------/
   High Dword         Low Dword



EXECUTÁVEL NO DISCO

SOMENTE SEÇÕES


EXECUTÁVEL NA MEMÓRIA
AS SEÇÕES + STACK E A HEAP JUNTO COM SUA ESTRUTURA DE CABEÇALHO PE(MZ, E_MAGIC, E_CP entre outros).
A organização é feita do mais baixo iniciando pela stack ao mais alto pela seção de recursos


BINÁRIO NA CPU VS BINÁRIO NA MEMÓRIA

CPU RECUPERA O CÓDIGO DA MEMÓRIA E INTERPRETA E EXECUTA, A MEMÓRA PROVA OS DADOS CONFORME VAI SENDO NECESSÁRIO

Visão geral CPU - MEMORIA:
1° O programa (no qual contem o código e os dados) são carregados na memória
2º A CPU busca as intruções de maquina, decodifica, e executa
3º A CPU busca os dados necessários na memória e os dados após processados são escritos na memória


O nome real do Assembly da intel é IA-32(32 bits) or IA-64(64 bits)

Exemplo do livro do printf da tela:
push EBP
mov ebp, esp
push ecx
mov dword ptr ss:[ebp-4], string_printf.0x10000 ; move a string para a stack "Simples printf"
push eax
push string_printf.0x100001 ; manda a string para pilha "%s"
call dword ptr ds:[<&printf>] ; chama a função responsável pelo printf
add esp, 8
xor eax, eax ; zera o retorno(se tiver)
mov esp, ebp
pop ebp ; popa o registrador
ret



ANOTAÇÃO DE DIFERENÇAS ENTRE CHAMADAS
SS É O SEGMENTO DE STACK
DS É O SEGMENTO DE DATA
PTR É UM PONTEIRO OU SEJA UM ENDEREÇO




- Registradores separados por importancia:
- Propósito geral:
EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI

- Na memória os dados podem ocupar necessáriamente os seguintes espaços:
32-bit(4 Bytes), 16-bit(2 Bytes), 8-bit(1 Byte)

- As partes menores podem acessada pelas partes baixas dos registradores como:
ax, bx dx, sp, si, di

- um detalhe é que os menores de 8 bits podem ser acessados pelas seguintes partes:
al, bl, cl e dl

- outro detalhe é que a parte alta de 8 bits podem ser acessados pelas seguintes partes:
ah, bh, ch e dh

- EIP
É O CONTADO DE PROGRAMAS, ARMAZENA A PRÓXIMA INSTRUÇÃO A SER EXECUTADA DA MEMÓRIA

- EFLAGS
NÃO MUITO REFERENCIADOS POREM USADOS DURANTE A EXECUÇÃO OU SOMENTE COM INSTRUÇÕES CONDICIONAIS
ELES SÃO:
cs, ss, ds, es, fs e o gs

- A mais básica instrução é o MOV que nada mais faz que transferir um dado de uma origen para um destino

- Movendo uma constante para um registrador
mov eax, 10  ; Move 10 para dentro do registrador EAX, é o mesmo que dizer que EAX = 10
mov bx, 7    ; Move 10 para dentro do registrador bx, é o mesmo que dizer que bx = 7
mov eax, 64h ; Move 0x64 para dentro do registrador eax, é o mesmo que dizer que eax = 64 | OBS: depende do interpretador alguns como o x64dbg usam mov eax, 0x64

- Movendo valor entre registradores
mov eax, ebx ; move o conteúdo de um registrador para outro, nesse caso ebx para eax

- Movendo os valores da memória para registradores

exemplo de c
int val = 100;

As seguintes ações acontecem na memória do programa:
1º Um inteiro tem 4 bytes de tamanho, então uma sequencia de 4 bytes (00 00 00 64) é armazenada em memória
2º A sequencia de 4 bytes são armazenados no padrão little-endian
3º Um valor inteiro de 100, ocupará 100 na memória como no seguinte exemplo:
0x403001  -> 00
0x403000  -> 100

- Movendo valores de offsets e endereços de memória
Para mover um valor da memória para dentro de um registrador usa-se o endereço do valor, a seguinte instrução acessa esse endereço para recuperar o valor
mov eax, [0x403000]; eax agora contém o valor do int 100 do exemplo anterior, no caso (00 00 00 64), usar [] recupera um valor de dentro do endereço e o move para o registrador

- Estrutalmente movendo valores de offsets e endereços de memória acessados por registradores e offsets de memória
Durante a engenharia rever é possível se deparar com instruções como nos exemplo abaixo onde [] referenciam um endereço a ser acessado na memória do computador,
sendo composto pelo registrador com algum offset
mov eax, [ebx] ; Move um valor de um endereço especificado pelo registrador ebx
mov eax, [ebx+ecx] ; Move um valor de um endereço especificado pela soma de dois registradores eax e ecx
mov eax, [ebp-4] ; Move um valor de um endereço especificado pela subtração de ebp e 4

- Instrução lea  para carregar endereços efetivos
Um outra instrução que provavelmente crusara é a LEA que é usada para carregar valores de endereços efetivos ou seja ao invés de carregar o valor no registrador ela carregara o endereço dele
lea ebx, [0x403000] ; Carrega o endereço 0x403000 dentro do registrador ebx
lea eax, [ebx]  ; Carrega o endereço presente em ebx para eax, então se ebx tiver = 0xB0B0C4 ou 0xDEADBEEF então eax também tera 0xB0B0C4 ou 0xDEADBEEF

- Estruturalmente movendo valores de offsets e endereços de memória acessados por registradores e offsets de memóra e recuperando o valor de outra forma
mov eax, dword ptr [ebp-4] ; é o mesmo que o mov eax, [ebp-4]

- Movendo valores de registradores para a memória
É possível mover valores de um registrador para a memória usando os operadores de troca como o MOV para isso basta inverter as posições como no exemplo abaixo:
mov [0x403000], eax  ; Move 4 bytes presentes no registrador eax para uma localização da memória com permissões na seção de RW inciando a partir do endereço 0x403000
mov [ebp], eax       ; Move 4 bytes presentes no registrador eax para um localização do endereço presente em ebp com permissões na seção de RW iniciando a partir do endereço presente no registrador EBP

outra forma comum também e que é possível se deparar é com instruções que movem valores constantes para dentro de localização de memória, como no seguinte exemplo:
mov dword ptr [0x403000], 13498h  ; Move um valor dword dentro do endereço 0x403000, pode-se omitir o dword e o ptr pois ele somente indica que estamos movendo um valor dword 4 bytes
mov dword ptr [ebx], 100  ; Move um valor dword 100 para dentro de um endereço especificado em ebx
mov word ptr [ebx], 100 ; Move uma word 100 para dentro do endereço especificado por ebx

* Na memória o endereço movido para ela é armazenado a partir do endereço especificado e ocupara o tamanho sobrepondo outros valores

 - vá para os exercícios de assembly da página 114, acesse Exercícios /disassembly_challenge_1_pg_114.asm
