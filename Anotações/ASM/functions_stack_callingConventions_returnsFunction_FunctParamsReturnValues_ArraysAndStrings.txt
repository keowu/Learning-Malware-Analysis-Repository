Conteúdo de anotações das páginas 134 - 147

- Functions
Uma função é um bloco de código que executa tarefas especificas, normalmente, um programa possui diversas funções, quando uma função é chamada, o
controle é transferido para um endereço diferente da memória, Então a CPU executa o código do endereço da memória, após retorna ao endereço original
no qual foi chamado anteriormente, As funções contem diversos componentes, ela pode obter seus dados via parâmetros, eles também possuem um corpo
onde fica seu código, elas contem variáveis locais para armazenamento temporário, e retornam dados.

- Stack
A stack é uma área da memória alocada pelo sistema operacional, na qual baseia-se no conceito LIFO(Last IN First OUT), que nada mais é que o primeiro
a entrar é o útlimo a sair e o último a entrar é o primeiro a sair, é possível adicionar dados na stack por meio da instrução push, e para remover dados
é possível através da instrução pop, o PUSH usa 4 bytes da stack, e a POP usa 4 bytes do topo da stack, um exemplo do uso:

push origem ; push para a origem ficar no topo da stack
pop destino ; pop copia um valor do topo da stack para o destino

A Stack cresce do maior endereço para o menor endereço, o registrador ESP(também chamado de ponteiro da stack) aponta ao topo da stack, ou endereço mais alto,
quando a intrução push é feita você manda valores para dentro da stack é decrementado 4 bytes da stack (ESP - 4) do menor endereço, já quando um pop é efetuado
é incrimentado 4 bytes ao valor de ESP do topo da stack (ESP + 4), observe o seguinte código assembly e tente entender como é o funcionamento da stack:

push 3
push 4
pop ebx
pop edx

Depois de executar as intruções, o registrador ESP aponta ao topo da stack(por exemplo, no endereço 0xFF8c), como mostrado:
				      ___________________________
ESP -------------------------------->| 				 | 0xff8C
(Topo da stack)			     |___________________________|
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|


Depois que a primeira instrução foi executada (push 3), ESP foi decrementado em 4 (Porque a instrução push decrementa 4 bytes da stack), e o valor 3
foi adicionado a stack, agora, ESP aponta ao topo da stack ou seja endereço 0xFF88, depois da segunda instrução push 4, ESP é decrementado em 4 bytes novamente
e agora ESP é 0xFF84, no qual agora é o topo da stack, quando uma instrução POP EBX é executada o valor 4 que estáva no endereço (ESP + 4) é movido para o registrador EBX
e ESP é incrementado com 4 Bytes, então ESP agora aponta para a stack em 0xFF88, similiar, quando a instrução pop EDX é executada o valor 3 é movido para o registrador EDX
e ESP é incrementado com 4 Bytes(ESP + 4), e o topo passa a ser 0xFF8C, veja as ilustrações



EXECUTANDO AS INSTRUÇÕES PUSH
________________________________________________________________________________________________________________________________________________

1) Depois de executar o PUSH 3
				      ___________________________
				     | 				 | 0xff8C
				     |___________________________|
				     |		 3		 |
ESP -------------------------------->|___________________________| 0xFF88
(Topo da stack)			     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|





2) Depois de executar o PUSH 4

				      ___________________________
				     | 				 | 0xff8C
				     |___________________________|
				     |		  3		 |
				     |___________________________| 0xFF88
				     |		  4		 |
ESP -------------------------------->|___________________________| 0xFF84
(Topo da stack)			     |				 |
				     |				 |
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|


EXECUTANDO AS INSTRUÇÕES POP
________________________________________________________________________________________________________________________________________________

3) Depois de executar POP EBX


				      ___________________________
				     | 				 | 0xff8C
				     |___________________________|
				     |		  3		 |
ESP -------------------------------->|___________________________| 0xFF88
(Topo da stack)			     |		  4		 |
	EBX = 4			     |___________________________| 0xFF84
				     |				 |
				     |				 |
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|



4) Depois de executar POP EDX



				      ___________________________
				     | 				 | 0xff8C
ESP -------------------------------->|___________________________|
(Topo da stack)			     |		  3		 |
	EDX = 3			     |___________________________| 0xFF88
				     |		  4		 |
				     |___________________________| 0xFF84
				     |				 |
				     |				 |
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|




Nos diagramas anteriores, os valores após o popped da stack estarão fisicamente disponíveis na memória, porem foram lógicamente removidos da stack.


- Calling functions
A instrução CALL, pode ser usada para chamar uma função, o exemplo de uso dessa intrução é o seguinte:

call <nome_funcao> ; Efetua uma chamada para uma instrução determinada

Usando uma perspectiva de analise de código, pense que onde escrevi no exemplo anterior <nome_funcao> é o endereço no qual contem o bloco de código para ser executado.
Então quando uma instrução call é executada, o controle é transferido para o bloco de código especificado pelo endereço, mas isso só ocorre após armazenar o endereço 
para a próxima instrução, ou seja a instrução após a "call <nome_funcao>", após concluído o bloco de código chamado, o endereço de retorna anteriormente armazenado
é usado pelo contador de programas(EIP) para retornar a execução do programa.

- Returning from function
Na linguagem assembly, o retorno de uma função, é usado a instrução ret, essa instrução faz um POP no endereço do topo da stack, o endereço popped é armazenado
no registrador EIP e controla a transferencia do endereço popped.

- Function parameters and return values
Na arquitetura x86, o parametro de funções são aceitos usando eles são pushed para a stack para serem usados, e o valor de retorno da função é armazenado no registrador EAX
Para poder entender como funciona, vamos ver um exemplo usando um trecho em C, quando o seguinte programa é executado, a função main() chama a função test, os valores dos argumentos
são copiados para a variáveis locais x e y, e retorna 0, (Valor de retorno)
veja o exemplo:

int test(int a, int b){
  int x, y;
  x = a;
  y = b;
  return 0;
}

int main(){
   test(2, 3);
   return 0;
}


Primeiro, vamos entender como funciona nossa função main, a função foi traduzida para instruções assembly:

push 3         (1)		
push 2         (2)
call test      (3)
add esp, 8	; Depois que a função test for executada, o controle retornara aqui
xor eax, eax


As primeiras três instruções 1, 2 e 3, representam a chamada da função test(2, 3), o argumento 2 e 3 são mandados para a stack, depois a função é chamada de maneira reversa
(da direita para a esquerda), e o segundo argumento, 3, é armazenado na pilha ddepois do primeiro argumento, e após armazenar na stack os argumentos a função test é chamada feita, 
e o endereço da próxima instrução após a call é armazenada ou seja "add esp, 8", é armazenado na stack (é o endereço de retorno), e então o controle é transferido para o endereço
inicial de início do bloco da função. veja um exemplo:



				      ___________________________
				     | 				 | 0xFE50
ESP -------------------------------->|___________________________|
(Topo da stack)			     |		  .		 |
	 			     |___________________________| 0xFE4C
				     |		  .		 |
				     |___________________________| 0xFE48
				     |		  .		 |
				     |___________________________| 0XFE44
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|

				     Antes de executar as três primeiras instruções




				      ___________________________
				     | 				 | 0xFE50
ESP -------------------------------->|___________________________|
(Topo da stack)			     |		  3		 |
	 			     |___________________________| 0xFE4C
				     |		  2		 |
				     |___________________________| 0xFE48
				     |    Endereço de retorno	 |
				     |___________________________| 0XFE44
				     |				 |
				     |___________________________|
				     |				 |
				     |___________________________|

				     Depois de executar as três primeiras instruções



Agora, vamos focar na função test, como mostrado aqui:

int test(int a, int b){
    int x, y;
    x = a;
    y = b;
    return 0;
}


O seguinte techo é o equivalente a "tradução" da função test para Assembly:

push EBP               ; Armazena o valor do registrador EBP na stack                     (4)
mov EBP, ESP           ; Move o valor de ESP para EBP                                     (5)
sub ESP, 8             ; subtrai ESP, 8                                                   (8)
mov EAX, [EBP+8]       ; EAX = [EBP+8]                                  
mov [EBP-4], EAX       ; [EBP-4] = EAX
mov ECX, [EBP+ 0x0C]   ; ECX = [EBP + 0X0C]
mov [EBP-8], ECX       ; [EBP-8] = ECX
xor EAX, EAX           ; XOR EAX, EAX  -> ZERA RESULTADO DE RETORNO                       (9)
mov ESP, EBP           ; MOV ESP = EBP		    	 				  (6)
pop EBP                ; LIMPA TOPO DA PILHA						  (7)
ret                    ; RETORNA                               				  (10)


A primeira instrução (4) salva o valoes de EBP(Também chamado de frame pointer) na stack, isso só será recuperado quando a função executar um retn
como resultado teremos essa função sendo armazenada na stack, o registrador ESP sera decrementado em 4 bytes, e na próxima instrução, (5)
o valor de ESP é copiado para EBP, como resultado, porem ESP e EBP, apontão para o Topo da STACK como será mostrado no próximo exemplo, 
o EBP para agora mantera sua posição fixa, e será usado como referêncial de argumentos de funções e para variaveis locais.



				      ___________________________
				     | 				 | 0xFE50
				     |___________________________|
				     |		  3		 |
	 			     |___________________________| 0xFE4C
				     |		  2		 |
				     |___________________________| 0xFE48
				     |    Endereço de retorno	 |
				     |___________________________| 0xFE44
				     |		old EBP		 |
ESP -------------------------------->|___________________________| 0xFE40
(Topo da stack)			     |				 |
				     |___________________________|


Você normalmente encontrará push ebp e mov ebp, esp no inicio da maioria das funções, essas duas instruções tem o apelido de prólogo
Essas instruções são responsáveis por configurar o ambiente para a função trabalhar, nos pontos (6) e (7), as duas intruções (mov esp, ebp e pop ebp)
fazem as operações de prologo para a função, eles restoram o ambiente após a execução da função.

Nos pontos (8), sub esp, 8 ocorre um decremento do registrador ESP, isso é feito para alocar espaço para as variaveis(X e Y), agora a stack ficará da seguinte forma:



				      ___________________________
				     | 				 | 0xFE50
				     |___________________________|
				     |		  3		 |
	 			     |___________________________| 0xFE4C     EBP + 0C
				     |		  2		 |
				     |___________________________| 0xFE48     EBP + 8
				     |    Endereço de retorno	 |
				     |___________________________| 0xFE44
				     |		old EBP		 |
ESP -------------------------------->|___________________________| 0xFE40 <-- EBP
(Topo da stack)			 /   |		 		 |
			Espaço	|    |___________________________| 0xFE3C     EBP - 4
			para	|    |				 |
	     variaveis locais    \   |___________________________| 0xFE38     EBP - 8
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |			         |
				     |___________________________|

Perceba que o EBP continua fixo na posição, e os argumentos da função podem ser acessados por meio de offsets positivos de ebp(EBP + VALOR POSITIVO).
e as variáveis locais podem ser acessadas de offsets negativos de ebp(ebp - VALOR POSITIVO), por exemplo, no diagrama anterior, o primeiro argumento 2
pode ser acessado pelo endereço EBP+8, (Que originalmente representaria o valor de A), e o segundo argumento pode ser acessado do endereço ebp+0x0C
(Que originalmente representaria o valor de B), as variáveis locais pode ser acessado por ebp-4 (Que representaria a variável local X), 
e ebp-8(Que representaria a variável local Y).

 _ 
| |	A marioria dos compiladores(Como o Microsoft Visual C/C++ Compiler), fazem o uso de um registrador EBP fixo 	
| |     baseado em frames da stack para referenciar os argumentos das funções e as variaveis locais. Já o GNU Compilers(como o GCC)
| |	não fazem o uso de do EBP como base para busca na stack, mas usam uma diferente tecnica onde o ESP(STACK POINTER) é usado como
|_|     referencial para parametros da função e variáveis locais.
(_)
   

O seguinte código está presente dentro das funções, entre (8) e (6), como é mostrado aqui:

mov EAX, [EBP+8]
mov [EBP-4], EAX
mov ECX, [EBP+0x0C]
mov [EBP+8], ECX

Vamos renomear os argumentos ebp+8 como A e EBP+0x0C como B, O endereço EBP-4 pode ser renomeado como a variável X, e EBP-8 como a variável Y,
como mostrado aqui:

mov EAX, [A]
mov [X], EAX
mov ECX, [B]
mov [Y], ECX

Usando tecnicas cobridas anteriormente é possível traduzir para o seguinte pseudocódgio:

X = A
Y = B

Em (9), XOR EAX, EAX define o valor de EAX para 0, esse é o valor de retorno 0, o valor de retorno é sempre armazenado no registrador EAX,
A função de prólogo, instrução presentes em (6) e (7) recuperam o ambiente da função. A instrução mov ESP, EBP (6) copia o valor de EBP para ESP
como resultado, ESP está apontnado para o endereço em que EBP está apontando, e o POP (7) restaura o antigo EBP da stack, e após essa operação EBP será
incrementado com 4 Bytes, e após essas execução a stack ficara da seguinte forma:



				      ___________________________
				     | 				 | 0xFE50
				     |___________________________|
				     |		  3		 |
	 			     |___________________________| 0xFE4C     EBP + 0C
				     |		  2		 |
				     |___________________________| 0xFE48     EBP + 8
				     |    Endereço de retorno	 |
				     |___________________________| 0xFE44
				     |		old EBP		 |
ESP -------------------------------->|___________________________| 0xFE40 <-- EBP
(Topo da stack)			     |		  2		 |
				     |___________________________| 0xFE3C     EBP - 4
				     |		  3		 |
	     		             |___________________________| 0xFE38     EBP - 8
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |			         |
				     |___________________________|

No (10), quando uma instrução RET é executada, o endereço de retorno do topo da stack é popped para fora da stack, e colocado no registror EIP
após o controle é transferido para o endereço de retorno, isso é um "add ESP, 8" para a função principal, como um resultado para a instrução pop
esp é incrementado com 4 (ESP+4), e nesse ponto o controle é transferido de volta ao bloco da função main, executando o conjunto do endereço retornado
"add ESP, 8" isso recupera a stack para o estado de limpo, e o ESP é retornado para a posição original, até esse ponto os valores da stack foram removidos
veja o exemplo de como ficara:


				      ___________________________
				     | 				 | 0xFE50
ESP -------------------------------->|___________________________|
(Topo da stack)			     |		  3		 |
	 			     |___________________________| 0xFE4C     EBP + 0C
				     |		  2		 |
				     |___________________________| 0xFE48     EBP + 8
				     |    Endereço de retorno	 |
				     |___________________________| 0xFE44
				     |		old EBP		 |
				     |___________________________| 0xFE40 <-- EBP
				     |		  2		 |
				     |___________________________| 0xFE3C     EBP - 4
				     |		  3		 |
	     		             |___________________________| 0xFE38     EBP - 8
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |				 |
				     |			         |
				     |___________________________|


No exemplo anterior, a função main chama a função test e passa os parametros para a função test usando a stack(pela ordem direta para esquerda).
A função main é conhecida com a (autora da chamada), e a test(chamado ou função chamada), a função main após a a chamada da função, limpa a stack
usando o add esp, 8. Essa instrução tem efeito e remove os parametros que foram puxados para a stack, e ajusta o ponteiro da stack (esp) de volta
ao que era essa função usa __cdecl clling convention.

- Arrays and Strings
Um array é um lista que consiste em dados do mesmo tipo. Os elementos de um array são armazenados em posições continuas da memória, isso faz com que
elas se tornem fáceis de acessar um elemento do array, o seguinte código define um array de 3 inteiros na memória, e cada elemento desse array, 
ocupa 4 bytes da memória(int tem tamanho de 4 bytes):

int nums[3] = { 1, 2, 3 };

O nome do array nums é uma constante de ponteiro, que aponta para o primeiro elemento de um array(exato, o nome aponta para a base address do array)
em uma linguagem de alto nível, para acessar um elemento você precisa fornecer o nome do array e um idnex, por exemplo nums[0], o segundo elemento
nums[1] e assim sucessivamente, veja isso na memória:


	        _______________________________
               |                               |    .
	       |_______________________________| 
               |                               |    .
	       |_______________________________|    
               |                               |    .
	       |_______________________________|
               |                               |    .
	       |_______________________________| 
    NUMS[2]    |               3               |   0X4008
	       |_______________________________|
    NUMS[1]    |               2               |   0X4004 
	       |_______________________________|  
    NUMS[0]    |               1               |   0X4000
	       |_______________________________|
	       |                               |
	       |_______________________________|
	       |                               |
	       |_______________________________|
	       |            0x40000            |   0x3FF4
    NUMS       |_______________________________|


Na linguagem Assembly, o endereço de qualquer elemento no array é calculado usando os seguintes passos:


 - O Endereço base do array
 - O Index do elemento
 - O tamanho de cada elemento no array

Então quando usa-se nums[0] em qualquer liguagem de alto nível essa instrução é traduzida da seguinte forma:
[nums+0*<tamanho_do_tipo_do_dado_em_bytes>], onde zero é o indice do Array, nums é o endereço base do array na memória
do exemplo mostrado, veja os seguintes e como podem ser reescritos:

nums[0] = [nums+0*4] = [0x4000+0*4] = [0x4000] = 1 
nums[1] = [nums+1*4] = [0x4000+1*4] = [0x4004] = 2
nums[2] = [nums+2*4] = [0x4000+2*4] = [0x4008] = 3

Uma forma geral de representar o array inteiro nums é o seguinte:

nums[1] = nums+i*4

O seguinte exemplo mostra o formato para acessar cada selemtno do array
[endereço base + index * tamanho do elemento]


Desafio de Assembly #5
Traduza o seguite código para um linguagem de alto nível equivalente, use tecnicas e os conceitos aprendidos para conseguir resolver esse desafio.












