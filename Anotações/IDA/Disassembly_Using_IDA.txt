Conteúdo de anotações das páginas 156 - 176


- Ferramentas de analise de código

As ferramentas de analise de código podem ser descritas nas seguintes categorias:

Um Disassembler que é capaz de interpretar o código de máquina para instrução IA32 equivalentes, dando assim
o nome de analise estática de código, A analise estática é uma técnica que pode ser usada para entender e
interpretar o código de assembly para entender o escopo do programa, sem precisar executar.

Um Debugger é um programa capaz de interpretar o código de máquina durante a execução por partes, isso permite
que você controle o binário, você pode executar desde uma intrução até conjunto de instruções maiores, para isso
é usada a técnica da analise dinâmica, essa técnica ajuda você a determinar o escopo de execução e os aspectos de
um binário suspeito.

Um Decompiler que é um programa que traduz instruções de máquina para código de alto nível. o decompiler consegue
auxiliar no processo de engenharia reversa e consequentemente facilitar seu trabalho.

- Analise estática de código

No modo gráfico do IDA as setas verdes indicam qual salto será usado se a condição for verdadeira, as setas vermelhas
indicam que o salto será feito se a condição não for verdadeira, a seta azul é usada para salto incondicionais como o JMP.

Por padrão o modo de gráfico do IDA não exibe os endereços virtuais, para exibir é necessário ir em OPTIONS -> GENERAL e habilitar os prefixies

No modo de exibição texto do IDA temos as Setas Pontilhadas, elas representam saltos condicionais, e as Setas sem pontos são representados como
os saltos não condicionais, e as setas ao contrário indicam os loops.

- Janela de funções

A janela de funções mostra todas as funções que foram reconhecidas pelo IDA, e também mostra todas os endereços virtuais onde cada fução podem ser
encontrados, o tamanho da função e varios outros aspectos das funções.

- Janela de saída

A janela de saída mostra uma mensagem gerada pelo IDA e as saídas dos plugins do IDA, essas mensagens fornecem informações sobre a analise do binário
e deiversos outras operações que podem ser feitas.

- Janela do HexView

A janela do hex exibe as sequencias de bytes do dump, e também exibe a conversão desses bytes para o equivalente em ASCII, por padrão , A janelela do
hexview é sincronizada com o disassembler então é possível obter o equivalente tanto pelo disassembler como pelo hexview para isso basta selecionar com
o mouse.

- Janela de Structures

Clicando na janela de Structures a janela lista as Struturas padrões usadas pelo programa analisado, ela permite que você crie suas próprias estruturas.

- Janela de Imports

A janela de importações listam todas os imports usados pelo binário, essas funções podem ser importadas de outras DLL'S.

- Janela de Exports

A janela de exports lista todos as funções exportadas. as funções exportadas são normalmente encontradas em DLL's, essa janela é muito útil para encontrar imports estranhos.

- Janela de Strings

Por padrão o IDA não exibe a janela de strings, você pode exibir a Janela de Strings indo no menu VIEW -> OPEN SUBVIEWS -> STRINGS(Ou usar o atalho shift+f12), A janela de strings
exibe uma lista com as strings encontradas no binário e o endereço virtual onde elas estão localizadas, por padrão a Janela de Strings só exibe as strings terminadas com o \n.

- Janela de Segmentos

A janela de segmentos está disponível quando você usar a opção VIEW -> OPEN SUBVIEWS -> SEGMENTS (Ou usar o atalho shift + f7).
a janela de segmentos tem uma lista com todas as seções(.text, .data, e qualquer outra) que esteja disponível no header do binário.
ela exibe informações úteis como o endereço do início e do fim, e as permissões de memória para cada seção.

- Comprovando o disassmbler do IDA

Considere o seguinte programa simples, no qual a lógica é copiar uma variável local para outra.

int main(){
  int x = 1;
  int y;
  x = y;
  return 0;
}


Ao disassembler com o IDA o seguinte peseudocode é obtido:

; Atributtes: bp-based frame (1)

; int _cdecl main(int argc, const char** argv, const char **envp)

_main proc near (7)

var_8 = dword ptr -8 (3)
var 4 = dword ptr -4 (3)
argc = dword ptr 8   (3)
argv = dword ptr 0Ch (3)
envp = dowrd ptr 10h (3)

push ebp             (6)
mov ebp, esp	     (6)
sub esp, 8           (6)
mov [ebp+var_4], 1   (4)
mov eax, [EBP+var_4] (4)
mov [EBP+var_8], eax (5)
xor eax, eax         
mov esp, ebp         (6)
pop ebp	             (6)
retn                 


Pseudocode


push ebp             ; ESP
mov ebp, esp	     ; STACK
sub esp, 8           ; VSCC
mov [ebp+var_4], 1   ; [x] = 1 
mov eax, [EBP+var_4] ; EAX = [x]
mov [EBP+var_8], eax ; [y] = EAX
xor eax, eax         ; EAX = 0
mov esp, ebp         ; stack ret
pop ebp	             ; clean da stack
retn                 ; 0xC3 return

Pseudocode Clean

[X] = 1
[Y] = [X]
return 0; ;EAX É ZERADO COM XOR EAX, EAX

C equivalente

void main(int argc, const char** argv, const char **envp){
   int x, y;
   x = 1;
   y = x;
   return 0;
}


- Renomeando variáveis locais

Para renomear as variáveis locais no IDA clique com o botão direito
em cima de alguma variável e escolha a opção rename, ou pressione o atalhe N

- Comentário no IDA

Comentários no ida podem ser feitos com o atalho (;) em cima da instrução desejada.


- Novo desafio, com outro disassembler no IDA


var_C = dword ptr -0Ch
var_8 = dword ptr -8
var_4 = dword ptr -4
argc = dword ptr 8
argv = dword ptr 0Ch
envp = dword ptr 10h


push ebp                                 ; Stack ret
mov ebp, esp			         ; Stack configure
sub esp, 0ch				 ; Stack diferença
mov dword_403374, 29h			 ; x = 0x29
mov byte_403370, 41h                     ; y = 0x41
mov [EBP+var_4], eax                     ; z = EAX
mov [EBP+var_8], offset dword_403374     ; c = x
mov [EBP+var_C], offset aTest ; "test"   ; a = "test"
xor eax, eax                             ; eax = eax ^ eax
mov esp, ebp				 ; stack return
pop ebp                                  ; clean stack
retn                                     ; return


Pseudocode

x = 0x29
y = 0x41
z = EAX
c = x
a = "test'
eax = 0
return

pseudo c

void main(){
  int x = 0x29;
  char y = '\x41';
  int c = x;
  char* a = "test";
  return 0;
}

- Formatando operandos

Com o botão direito é possível alterar os tipos de dados no IDA para isso selecione um valor
exibido e escolha uma opção entre decimal, octal, binary e hexadecimal.

- Referências cruzadas e todas as referências cruzadas

Uma outra maneira de navegação pelo código assembly é usando as referencias cruzadas das intruções,
esse recurso permite por exemplo encontrar referencias apertando o atalho (X), em cima de uma call~
ou para um determinado endereço.

Desafio 2

mov [ebp + var_4], 0   ; x = 0
cmp [ebp + var_4], 0   ; x com zero x - 0 = 0 ??
jnz short loc_401018   ; pula se não for zero
mov [ebp+var_4], 5     ; se for zero

loc_401018:            ; se não for zero
mov [ebp + var_4], 2   ; x = 2



pseudocode

mov [x] = 0
cmp [x], 0
jnz loc_401018
mov [x], 5

loc_401018:
mov [x], 2


pseudocode C
x = 0
if(x == 0){
  x = 5;
}else{
  x = 2;
}


Exemplo de subcalls

void test(){
}

void main(){
   test();
}


Disassembler equivalent

push ebp	 ; Ret
mov ebp, esp     ; Stack Configure
call sub_401000	 ; Call routine
xor eax, eax	 ; xor eax, eax


sub_401000:
push ebp         ; ret
mov ebp, esp     ; stack configura
pop ebp          ; stack limpa
retn             ; return


pseudocode

call sub_401000
eax = 0

sub_401000:
push ebp
mov ebp, esp
pop ebp
retn

pseudocode c

void x(){
  return;
}

void main(){
  x();
  return 0;
}


























